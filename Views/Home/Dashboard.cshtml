@using AdminLTE_MVC.Helpers.Generators;
@using AdminLTE_MVC.Snmp;

@{
    CardGenerator.ResetCardCount();  // I don't like this (~see CardGenerator.CardCount for future fix, the reset method should be in the aforementioned model/data class)
}
<!-- Modal Popup -->
<div class="modal fade" id="dialog" runat="server">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h4 class="modal-title">Create New Card</h4>
        <button type="button" class="close" data-dismiss="modal">&times;</button>
      </div>
      <div class="modal-body">
        <form>
          <div class="card-body">
            <!-- Title Field -->
            <div class="form-group">
              <label for="Title">Card Title</label>
              <input type="text" class="form-control" id="cardTitle" placeholder="Auto-select Title" />
            </div>

            <!-- Element Field -->
            <div class="form-group">
              <label for="Name">Element</label>
              <select class="custom-select" id="cardTitle">
                @(new ListGenerator(Model.Target).Generate())
              </select>
            </div>
          </div>
          <div class="card-footer">
            <button type="submit" class="btn btn-primary">Submit</button>
          </div>
        </form>
      </div>
    </div>
  </div>
</div>

<!-- Content Header -->
<div class="content-header">
  <div class="container-fluid">
    <div class="row mb-2">
      <div class="col-sm-2">
        <h1 class="m-0">Widgets
        </h1>
      </div>
      <button type="button" id="btn" class="btn btn-primary" data-bind="modal">
        Create New <i class="fas fa-plus"></i>
      </button>
    </div>
  </div>
</div>

@{
    List<CardGenerator> generators = new();
    generators.Add(new CardGenerator(Model.Target[0]));
    generators.Add(new CardGenerator(Model.Target[1]));
    generators.Add(new CardGenerator(Model.Target[2]));
    generators.Add(new CardGenerator(Model.Target[3]));
    generators.Add(new CardGenerator(Model.Target[4]));
}

<!-- Content -->
<div class="content">
  <div class="container-fluid">
    <!-- First Row -->
    <div class="row row-auto">
      <!-- Column A -->
      <section class="col-lg-3 connectedSortable ui-sortable">
        @generators[0].Generate()
        @generators[1].Generate()
      </section>

      <!-- Column B -->
      <section class="col-lg-3 connectedSortable ui-sortable">
        @generators[2].Generate()
      </section>

      <!-- Column C -->
      <section class="col-lg-3 connectedSortable ui-sortable">
        @generators[3].Generate()
      </section>

      <!-- Column D -->
      <section class="col-lg-3 connectedSortable ui-sortable">
        @generators[4].Generate()
      </section>
    </div>
  </div>
</div>

<script>
// Serialize gauge values into json and save the values inside variables
const nameList            = JSON.parse('@Html.Raw(Json.Serialize(Model.DataCollector.Names))');
const valueList           = JSON.parse('@Html.Raw(Json.Serialize(Model.DataCollector.Values))');
const minList             = JSON.parse('@Html.Raw(Json.Serialize(Model.DataCollector.Mins))');
const lowAlarmList        = JSON.parse('@Html.Raw(Json.Serialize(Model.DataCollector.LowAlarms))');
const lowWarningList      = JSON.parse('@Html.Raw(Json.Serialize(Model.DataCollector.LowWarnings))');
const highWarningList     = JSON.parse('@Html.Raw(Json.Serialize(Model.DataCollector.HighWarnings))');
const highAlarmList       = JSON.parse('@Html.Raw(Json.Serialize(Model.DataCollector.HighAlarms))');
const maxList             = JSON.parse('@Html.Raw(Json.Serialize(Model.DataCollector.Maxes))');
const generatorList       = JSON.parse('@Html.Raw(Json.Serialize(generators))');

console.log(generatorList)

let gauge = [];

// Looping through cards
for (let i = 0; i < @Model.DataCollector.CardCount; i++) {
    const value             = parseFloat(valueList[i]);
    const minValue          = parseFloat(minList[i]);
    const lowAlarmValue     = parseFloat(lowAlarmList[i]);
    const lowWarningValue   = parseFloat(lowWarningList[i]);
    const highWarningValue  = parseFloat(highWarningList[i]);
    const highAlarmValue    = parseFloat(highAlarmList[i]);
    const maxValue          = parseFloat(maxList[i]);
    const genId             = parseInt(generatorList[i].id);    // Why this is 'id' instead of 'Id' is beyond me...

    const options = {
    // color configs
    colorStart: "#6fadcf",
    colorStop: void 0,
    gradientType: 0,
    strokeColor: "#e0e0e0",
    generateGradient: true,
    percentColors: [[0.0, "#a9d70b" ], [0.50, "#f9c802"], [1.0, "#ff0000"]],
    // customize pointer
    pointer: {
      length: 0.8,
      strokeWidth: 0.035,
      iconScale: 1.0
    },
    // render ticks
    renderTicks: {
      divisions: 5,
      divWidth: 1.1,
      divLength: 0.7,
      divColor: "#333333",
      subDivisions: 3,
      subLength: 0.5,
      subWidth: 0.6,
      subColor: "#666666"
    },
    // static zones
    staticZones: [
        { strokeStyle: "#F03E3E", min: minValue,          max: lowAlarmValue },
        { strokeStyle: "#FFDD00", min: lowAlarmValue,     max: lowWarningValue },
        { strokeStyle: "#30B32D", min: lowWarningValue,   max: highWarningValue },
        { strokeStyle: "#FFDD00", min: highWarningValue,  max: highAlarmValue },
        { strokeStyle: "#F03E3E", min: highAlarmValue,    max: maxValue },
    ],
    // static labels
    staticLabels: {
        font: "10px sans-serif",
        labels: [minValue, lowAlarmValue, lowWarningValue, highWarningValue, highAlarmValue, maxValue],
        fractionDigits: 0,
    },
    // the span of the gauge arc
    angle: 0.1,
    // line thickness
    lineWidth: 0.44,
    // radius scale
    radiusScale: 1.0,
    // font size
    fontSize: 40,
    // if false, max value increases automatically if value > maxValue
    limitMax: false,
    // if true, the min value of the gauge will be fixed
    limitMin: false,
    // High resolution support
    highDpiSupport: true
};

    const currentElementId = "gauge" + genId;
    gauge[i] = new Gauge(document.getElementById(currentElementId)).setOptions(options);

    gauge[i].minValue = minValue;
    gauge[i].maxValue = maxValue;
    gauge[i].set(value)
}
</script>
<script src="~/js/pages/popup.js"></script>
<script src="~/js/pages/sorting.js"></script>
